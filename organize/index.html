<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../stylesheets/pygment_trac.css" media="screen" />

    <script src="../javascripts/libs/pace.js"></script>
    <link rel="stylesheet" type="text/css" href="../stylesheets/pace-theme-loading-bar.css" media="screen" />

    <script src="../javascripts/libs/jquery-1.10.2.js"></script>
    <script src="../javascripts/libs/jszip.min.js"></script>
    <script src="../javascripts/libs/FileSaver.min.js"></script>
    <script src="../javascripts/utils.js"></script>
    <script src="sha1.js"></script>
    <script src="mapdefaults.js"></script>
    <script src="mapper.js"></script>
<script>


$(function() {

  dcmjs.utils.initialize();

  // the current pending set of files, as in what was
  // dropped or selected by the user (the input)
  var fileSet = new Set();

  // a zip object in which to place the organized
  // DICOM data (the output)
  var zip = new JSZip();

  // utility: todo: keep a log for optional download
  var print = function(s) {
    console.log(s);
    $('#main_content').append('<p class="output">%s</p>'.replace('%s', s));
  };

  // utility: check path in virtual fs
  var fileExists = function(filePath) {
      try {
        FS.stat(filePath);
      }
      catch(e) {
        if (e.code !== 'ENOENT') {
          print(e);
        }
        return false;
      }
      return true;
  };

  // utility: remove files in a file list (if they exist)
  var deleteFiles = function(filePaths) {
    $.each(filePaths, function(index,filePath) {
      try {
        FS.unlink(filePath);
      }
      catch(e) {
        if (e.code !== 'ENOENT') {
          print(e);
        }
      }
    });
  };

  // returns xml string
  var xmlFromDICOM_dcm2xml = function(file, filePath) {
    var xmlFilePath = '/uploadedFile.xml';

    // perform the xml dump
    file.name, dcmjs.utils.execute('dcm2xml', ['--load-all', '--encode-base64', '--write-binary-data', filePath, xmlFilePath]);
    file.name, dcmjs.utils.execute('dcm2xml', [filePath, xmlFilePath]);
    if (!fileExists(xmlFilePath)) {
      print ('skipping non-DICOM file because no xml generated for ' + file.name);
      finalizeFile(file);
      return;
    }
    var xmlString = FS.readFile(xmlFilePath, {encoding: 'utf8'} );
    deleteFiles([xmlFilePath]);
    return xmlString;
  }

  // returns xml string from dump string
  var dumpToXML = function(dumpLines) {
    var xml = '';
    xml += '<?xml version="1.0" encoding="ISO-8859-1"?>\n';
    xml += '<file-format>\n';
    xml += '<meta-header xfer="1.2.840.10008.1.2.1" name="Little Endian Explicit">\n';

    $.each(dumpLines, function (index, line) {

  if (line.search("PixelData") !== -1) {
    console.log(line);
  }

      line = line.trim();
      if (line.length === 0) { return; };
      if (line.search('Unknown Tag & Data') != -1) {
        // TODO: better way to handle unknown private data?
        return;
      }
      line = line.replace('&', '&amp');
      if (line.search('# Dicom-Data-Set') != -1) {
        xml += '</meta-header>\n';
        xml += '<data-set xfer="1.2.840.10008.1.2" name="Little Endian Implicit">\n';
        return;
      }
      if (line[0] === '#') { return; };
      if (line[0] === '(') {
        var parts = line.split(' ');
        var tag = parts[0].substring(1,10);
        var vr = parts[1];
        var vm = parts[parts.length-2];
        var len = parts[parts.length-3];
        len = len.substring(0,len.length-1);
        var name = parts[parts.length-1];

        var value = '';
        if (vr === '??') { vr = "UN"; }
        if (line.search('(no value available)') != -1) {
          len = 0;
        } else {
        // adding else so non-bracketed values don't return invalid data
          var openBracket = line.indexOf('[');
          var closeBracket = line.lastIndexOf(']');
          if (openBracket > 0 && closeBracket > 0) {
            value = line.substring(openBracket+1, closeBracket);
          }
          else {
            // assuming US, UL which are not bracketed
            // TODO(@Steve): review whether in line with overall implementation
            value = parts[2];
          }
        }

        xml += '<element tag="' + tag + '" ';
        xml += 'vr="' + vr + '" ';
        xml += 'vm="' + vm + '" ';
        xml += 'len="' + len + '" ';
        xml += 'name="' + name + '">';
        xml += value + '</element>\n';
    }
    });

    xml += '</data-set>\n';
    xml += '</file-format>\n';

    return(xml);
  }

  // returns xml string
  var xmlFromDICOM = function(file, filePath) {
    var dumpPath = '/uploadedFile.txt';

    // create a dump file
    // - a <fileName>.0.raw file will be created in .
    var dumpLines = [];
    Module.print = function(s) { dumpLines.push(s) }
    var returnCode = dcmjs.utils.execute('dcmdump', ['--print-all', '--write-pixel', '.', '--no-uid-names', filePath]);
    Module.print = print;

    print('returnCode', returnCode); // TODO

    var rawFilePath = filePath + ".0.raw";
    if (!fileExists(rawFilePath)) {
      print ('skipping non-DICOM file because no raw file generated for ' + file.name);
      finalizeFile(file);
      return;
    }

    return (dumpToXML(dumpLines));
  }

  // converts a jquery dom object into a
  // string in dcmdump format.
  var dicomDOMToDump = function($dicomDOM) {
    var dump = '';
    $dicomDOM.find('data-set').find("element").each(function() {
      var tag = this.getAttribute('tag');
      var vr = this.getAttribute('vr');
      var value = this.innerHTML;
      // TODO: move private tag handling to the mapper
      var privateTag = (Number("0x"+tag[3]) % 2 === 1);
      // TODO: move pixel data handling to the mapper
      var pixelData = (tag === "7fe0,0010");

      if (!privateTag) {
        if (pixelData) {
          // FIXME: special case based on known file names
          dump += '(7fe0,0010) OW =./uploadedFile.dcm.0.raw';
        } else {
          dump += '(' + tag + ') ' + vr + ' [' + value + ']\n';
        }
      }
    });
    console.log(dump);
    return(dump);
  };

  // adds contents to zip object at specified path.
  // removes file from input set.
  // triggers zip creation and download when set is empty.
  var finalizeFile = function(file, path, contents) {
    fileSet.delete(file);
    print('file set size: ' + fileSet.size);
    if (path) {
      zipContents = new Uint8Array(contents);
      print('adding ' + path + "  of size " + zipContents.length);
      zip.file(path, zipContents, {binary: true});
    }
    if (fileSet.size === 0) {
      var content = zip.generate({type:"blob"});
      // see FileSaver.js
      saveAs(content, "organizedDICOM.zip");
    }
  };


  // process one file from the input set.
  var organize = function(reader, file) {
    var fileName = file.name;
    var uploadedFilePath = '/uploadedFile.dcm';
    var organizedXMLFilePath = '/organizedObject.xml';
    var organizedDICOMFilePath = '/organizedObject.dcm';

    // Delete anything left from previous runs
    deleteFiles([uploadedFilePath, organizedXMLFilePath, organizedDICOMFilePath]);

    print('Writing...');
    var uploadedObject = new Int8Array(reader.result);
    FS.writeFile(uploadedFilePath, uploadedObject, {encoding: "binary"});

    var xmlString = xmlFromDICOM(file, uploadedFilePath);

    // TODO:
    // - pass filePath from closure
    // - pass mapping table from uploaded file (currently statis list in mapconfig.js)
    var filepath, mapFile;
    var $newDicomDOM = mapDom(xmlString, filepath, mapFile, {print: print});

    // manipulate the dom
    print(file.name);
    window.$newDicomDOM = $newDicomDOM;



    // write the new xml and covert it to dicom
    var organizedObject = (new XMLSerializer()).serializeToString($newDicomDOM[0]);
    FS.writeFile(organizedXMLFilePath, organizedObject);

    // make a clean study path based on the contents of the file
    var names = [ 'PatientName',
                  'Modality',
                  'StudyDescription',
                  'StudyDate',
                  'SeriesNumber',
                  'SeriesDescription',
                  'InstanceNumber'];
    var valuesByName = {};

    // replace spaces with underscores and other special chars with %xx uri code
    var findSpaces = new RegExp(' ', 'g');
    $.each(names, function (index, name) {
      var value = $newDicomDOM.find('[name='+name+']').text();
      value = value.replace(findSpaces, '_');
      valuesByName[name] = encodeURIComponent(value);
    });

    var studyPath = '/' + (valuesByName['PatientName'] ||Â 'na') + '-' +
                   valuesByName['Modality'] + '-' +
                   valuesByName['StudyID'] + '_' +
                   valuesByName['StudyDescription'] + '-' +
                   valuesByName['StudyDate'];
    var instanceFilePath = studyPath + '/' + valuesByName['SeriesNumber'] + '_' +
                       valuesByName['SeriesDescription'] + '-' +
                       valuesByName['InstanceNumber'] + '.dcm';

    // old way:
    // perform the xml undump
    /////dcmjs.utils.execute('xml2dcm', [organizedXMLFilePath, organizedDICOMFilePath]);


    // conver to dump and save
    var dump = dicomDOMToDump($newDicomDOM);
    FS.writeFile('./dump.txt', dump, {encoding: 'utf8'} );

    // perform the dump to dcm
    dcmjs.utils.execute('dump2dcm', ['--ignore-errors', "./dump.txt", organizedDICOMFilePath]);
    var organizedObject = FS.readFile(organizedDICOMFilePath, {encoding: 'binary'} );

    print(instanceFilePath + "  of size " + organizedObject.length);
    finalizeFile(file, instanceFilePath, organizedObject);

    if (false) {

      // debug download code
      print("dumping");
      var dump = "";
      Module.print = function(s) { dump += s; }
      dcmjs.utils.execute('dcmdump', [organizedDICOMFilePath]);
      Module.print = print;
      print(dump);


      // var blob = new Blob([organizedObject], {type: 'application/dicom'});
      // saveAs(blob, "organized.dcm");
    }


  }

  // Used for file selection button or drop of file list
  var readSelectedFiles = function(files) {
    $.each(files, function(index,file) {
      fileSet.add(file);
      dcmjs.utils.readFile(file, organize);
    });
  }


  function fsErrorHandler(e) {
      console.log('FileSystem API error code: ' + e.name);
      console.log(e);
  }

  // File selector
  function handleFileSelect(e) {
    evt = e.originalEvent
    var files = evt.target.files; // FileList object
    readSelectedFiles(files);
  }

  // Recursive directory read, callback per File
  function readEntry(entry,callback) {
    if (entry.isFile) {
      print(entry.fullPath);
      if (entry.name.indexOf('.') === 0) {
        print('ignoring ', entry.fullPath);
        return;
      }
      entry.file(callback, fsErrorHandler);
    } else {
      if (entry.createReader) {
        var directoryReader = entry.createReader();
        var entryHandler = function (results) {
          if (results.length) {
            $.each(results, function(index, entry) {
              readEntry(entry,callback);
            });
            directoryReader.readEntries(entryHandler, fsErrorHandler);
          }
        };
        directoryReader.readEntries(entryHandler, fsErrorHandler);
      }
    }
  }

  // Setup the file selector listener
  $('#fileSelector').bind('change', handleFileSelect)

  // Drag and Drop
  function handleFileDrop(e) {
    var evt = e.originalEvent;
    evt.stopPropagation();
    evt.preventDefault();

    // Clean up any previous output
    $('#main_content p.output').remove();

    // handle the items or files
    var length = evt.dataTransfer.items.length;
    if (length > -1) {
      // chrome-only transfer that can include dropped directories
      for (var i = 0; i < length; i++) {
        var entry = evt.dataTransfer.items[i].webkitGetAsEntry();
        readEntry(entry, function(file) {
          fileSet.add(file);
          dcmjs.utils.readFile(file, organize);
        });
      }
    } else {
      // compatible file-based selection
      var files = evt.dataTransfer.files; // FileList object
      readSelectedFiles(files);
    }
  }

  // Setup the dnd listeners
  function ignoreDrag(e) {
    e.originalEvent.stopPropagation();
    e.originalEvent.preventDefault();
    e.originalEvent.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
  }
  $('#fileDropZone').bind('dragenter', ignoreDrag).bind('dragover', ignoreDrag).bind('drop', handleFileDrop);

  //  Override print so dcmjs commands will print to web page
  var printToMainContext = function(s) {
    $('#main_content').append('<p class="output">' + s + '</p>');
  };
  Module.print = printToMainContext;


});

</script>

    <title>dcmjs by commontk</title>
  </head>

  <body>

<header>
  <div class="container">
    <h1>dcmjs organize</h1>
    <h2>Organize and anonymize dicom files in your browser (they are not sent to a server)</h2>

    <h2>NOTE: this is still a work in progress and is not yet ready for routine use!</h2>
  </div>
</header>



<!--
Main interface for data upload
-->
<div class="container">
  <section id="main_content" style="display:none;">

    <!-- File selector -->
    <p>Browse for DICOM files:</p>
    <input type="file" id="fileSelector" name="selectorFiles[]" multiple />

    <p>Or</p>

    <!-- Drag and Drop -->
    <div class="files_wrapper">
      <div class="area_file" id="fileDropZone">Drop your DICOM files here</div>
    </div>

    <output id="fileListProperties"></output>

    <p class='output'>Waiting...</p>

    <div id='viewContainer'></div>

  </section>
</div>



<!-- google analytics -->
<script type="text/javascript">
  var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
  document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
  try {
    var pageTracker = _gat._getTracker("UA-50750505-1");
  pageTracker._trackPageview();
  } catch(err) {}
</script>

  </body>
</html>
